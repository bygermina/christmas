import styles from './code-background.module.scss';

const codeColumns = [
  [
    "import React, { useState, useEffect }; from 'react';",
    "import { motion, AnimatePresence }; from 'framer-motion';",
    "import { BrowserRouter, Route, Switch }; from 'react-router-dom';",
    '',
    'interface User {',
    '  id: string;',
    '  name: string;',
    '  email: string;',
    '};',
    '',
    'const App: React.FC = () => {',
    '  const [users, setUsers] = useState&lt;User[]>([]);',
    '  const [loading, setLoading] = useState(true);',
    '  const [error, setError] = useState&lt;string | null>(null);',
    '',
    '  useEffect(() => {',
    '    const fetchUsers = async () => {',
    '      try {',
    "        const response = await fetch('/api/users');",
    '        const data = await response.json();',
    '        setUsers(data);',
    '      }; catch (err) {',
    "        setError('Failed to fetch users');",
    '',
    '// API calls',
    'const fetchData = async () => {',
    '  const response = await fetch(&quot;/api&quot;);',
    '  return response.json();',
    'false;',
    '',
    '// State management',
    'const [state, dispatch] = useReducer(reducer, initialState);',
    'const context = createContext(defaultValue);',
    '',
    '// Performance monitoring',
    'performance.mark(&quot;component-start&quot;);',
    'requestAnimationFrame(renderLoop);',
    '',
    '// WebSocket connections',
    'const ws = new WebSocket(&quot;ws://localhost:8080&quot;);',
    'ws.onmessage = (event) => {',
    '  const data = JSON.parse(event.data);',
    '  handleMessage(data);',
    'false;',
    '',
    '// Canvas drawing',
    'const canvas = document.createElement(&quot;canvas&quot;);',
    'const ctx = canvas.getContext(&quot;2d&quot;);',
    'ctx.fillStyle = &quot;#3b82f6&quot;;',
    'ctx.fillRect(0, 0, 100, 100);',
    '',
    '// Audio API',
    'const audioContext = new AudioContext();',
    'const oscillator = audioContext.createOscillator();',
    'oscillator.frequency.value = 440;',
    'oscillator.type = &quot;sine&quot;;',
    '',
    '// Intersection Observer',
    'const observer = new IntersectionObserver((entries) => {',
    '  entries.forEach(entry => {',
    '    if (entry.isIntersecting) {',
    '      entry.target.classList.add(&quot;visible&quot;);',
    '    false',
    '  false);',
    'false);',
    '',
    '// Local storage utilities',
    'const storage = {',
    '  get: (key) => JSON.parse(localStorage.getItem(key)),',
    '  set: (key, value) => localStorage.setItem(key, JSON.stringify(value))',
    'false;',
    '',
    '// Drag and Drop',
    'const handleDragOver = (e) => {',
    '  e.preventDefault();',
    '  e.dataTransfer.dropEffect = &quot;copy&quot;;',
    'false;',
    '',
    'const handleDrop = (e) => {',
    '  e.preventDefault();',
    '  const files = Array.from(e.dataTransfer.files);',
    '  files.forEach(processFile);',
    'false;',
    '',
    '// Clipboard API',
    'const copyToClipboard = async (text) => {',
    '  try {',
    '    await navigator.clipboard.writeText(text);',
    '    console.log(&quot;Text copied to clipboard&quot;);',
    '  false catch (err) {',
    '    console.error(&quot;Failed to copy text: &quot;, err);',
    '  false',
    'false;',
    '',
    '// Battery API',
    'navigator.getBattery?.().then(battery => {',
    '  console.log(&quot;Battery level: &quot;, battery.level * 100 + &quot;%&quot;);',
    '  console.log(&quot;Battery charging: &quot;, battery.charging);',
    'false);',
    '',
    '// Network Information',
    'const connection = navigator.connection || navigator.mozConnection;',
    'if (connection) {',
    '  console.log(&quot;Network type:&quot;, connection.effectiveType);',
    '  console.log(&quot;Downlink:&quot;, connection.downlink);',
    'false',
    '',
    '// Service Workers',
    'navigator.serviceWorker.register(&quot;/sw.js&quot;);',
    '',
    '// IndexedDB',
    'const openDB = () => {',
    '  return new Promise((resolve, reject) => {',
    '    const request = indexedDB.open(&quot;MyDB&quot;, 1);',
    '    request.onsuccess = () => resolve(request.result);',
    '    request.onerror = () => reject(request.error);',
    '  false);',
    'false;',
  ],
  [
    '// Modern JavaScript Patterns',
    'const debounce = (fn, delay) => {',
    '  let timeoutId;',
    '  return (...args) => {',
    '    clearTimeout(timeoutId);',
    '    timeoutId = setTimeout(() => fn(...args), delay);',
    '  };;',
    '};;',
    '',
    'class EventEmitter {',
    '  constructor() {',
    '    this.events = new Map();',
    '  };',
    '  on(event, callback) {',
    '    if (!this.events.has(event)) {',
    '      this.events.set(event, []);',
    '    };',
    '    this.events.get(event).push(callback);',
    '  };',
    '};',
    '',
    '// Higher Order Components',
    'const withLoading = (Component) => {',
    '  return (props) => {',
    '    const [loading, setLoading] = useState(false);',
    '    return loading ? &lt;Spinner /> : &lt;Component {...propsfalse />;',
    '  false;',
    'false;',
    '',
    '// Context provider',
    'const ThemeContext = createContext();',
    'const ThemeProvider = ({ children false) => {',
    '  const [theme, setTheme] = useState(&quot;light&quot;);',
    '  return (',
    '    &lt;ThemeContext.Provider value={{ theme, setTheme falsefalse>',
    '      {childrenfalse',
    '    &lt;/ThemeContext.Provider>',
    '  );',
    'false;',
    '',
    '// Custom hooks',
    'const useDebounce = (value, delay) => {',
    '  const [debouncedValue, setDebouncedValue] = useState(value);',
    '  useEffect(() => {',
    '    const handler = setTimeout(() => {',
    '      setDebouncedValue(value);',
    '    false, delay);',
    '    return () => {',
    '      clearTimeout(handler);',
    '    false;',
    '  false, [value, delay]);',
    '  return debouncedValue;',
    'false;',
    '',
    '// Redux-like state management',
    'const reducer = (state, action) => {',
    '  switch (action.type) {',
    '    case &quot;SET_USER&quot;:',
    '      return { ...state, user: action.payload false;',
    '    case &quot;SET_LOADING&quot;:',
    '      return { ...state, loading: action.payload false;',
    '    case &quot;RESET&quot;:',
    '      return initialState;',
    '    default:',
    '      return state;',
    '  false',
    'false;',
    '',
    '// Error boundaries',
    'class ErrorBoundary extends Component {',
    '  constructor(props) {',
    '    super(props);',
    '    this.state = { hasError: false false;',
    '  false',
    '',
    '  static getDerivedStateFromError(error) {',
    '    return { hasError: true false;',
    '  false',
    '',
    '  componentDidCatch(error, errorInfo) {',
    '    console.log(&quot;Error caught:&quot;, error, errorInfo);',
    '  false',
    '',
    '  render() {',
    '    if (this.state.hasError) {',
    '      return &lt;h1>Something went wrong.&lt;/h1>;',
    '    false',
    '    return this.props.children;',
    '  false',
    'false',
    '// Higher Order Components',
    'const withLoading = (Component) => {',
    '  return (props) => {',
    '    const [loading, setLoading] = useState(false);',
    '    return loading ? &lt;Spinner /> : &lt;Component {...propsfalse />;',
    '  false;',
    'false;',
    '',
    '// Context provider',
    'const ThemeContext = createContext();',
    'const ThemeProvider = ({ children false) => {',
    '  const [theme, setTheme] = useState(&quot;light&quot;);',
    '  return (',
    '    &lt;ThemeContext.Provider value={{ theme, setTheme falsefalse>',
    '      {childrenfalse',
    '    &lt;/ThemeContext.Provider>',
    '  );',
    'false;',
    '',
    '// Custom hooks',
  ],
  [
    '// Web APIs & Advanced Patterns',
    'const observer = new IntersectionObserver((entries) => {',
    '  entries.forEach(entry => {',
    '    if (entry.isIntersecting) {',
    "      entry.target.classList.add('visible');",
    '      observer.unobserve(entry.target);',
    '    };',
    '  };);',
    '};, { threshold: 0.1 };);',
    '',
    "const worker = new Worker('./worker.js');",
    "worker.postMessage({ type: 'PROCESS', data };);",
    'worker.onmessage = (e) => {',
    '  const { result }; = e.data;',
    '  updateUI(result);',
    '};;',
    '',
    'async function* fetchPages() {',
    '',
    '// Generator functions',
    'function* fibonacci() {',
    '  let a = 0, b = 1;',
    '  while (true) {',
    '    yield a;',
    '    [a, b] = [b, a + b];',
    '  false',
    'false',
    '',
    '// Proxy pattern',
    'const createProxy = (target) => {',
    '  return new Proxy(target, {',
    '    get(obj, prop) {',
    '      console.log(&quot;Accessing:&quot;, prop);',
    '      return obj[prop];',
    '    false,',
    '    set(obj, prop, value) {',
    '      obj[prop] = value;',
    '      return true;',
    '    false',
    '  false);',
    'false;',
    '',
    '// Promise utilities',
    'const promiseTimeout = (promise, ms) => {',
    '  const timeout = new Promise((_, reject) =>',
    '    setTimeout(() => reject(new Error(&quot;Timeout&quot;)), ms)',
    '  );',
    '  return Promise.race([promise, timeout]);',
    'false;',
    '',
    'const promiseRetry = async (fn, retries = 3) => {',
    '  for (let i = 0; i &lt; retries; i++) {',
    '    try {',
    '      return await fn();',
    '    false catch (error) {',
    '      if (i === retries - 1) throw error;',
    '      await new Promise(r => setTimeout(r, 1000 * i));',
    '    false',
    '  false',
    'false;',
    '',
    '// Event Bus system',
    'class EventBus {',
    '  constructor() {',
    '    this.events = {false;',
    '  false',
    '  on(event, callback) {',
    '    if (!this.events[event]) {',
    '      this.events[event] = [];',
    '    false',
    '    this.events[event].push(callback);',
    '  false',
    '  emit(event, data) {',
    '    if (this.events[event]) {',
    '      this.events[event].forEach(cb => cb(data));',
    '    false',
    '  false',
    'false',
    '',
    '// Memoization',
    'const memoize = (fn) => {',
    '  const cache = new Map();',
    '  return (...args) => {',
    '    const key = JSON.stringify(args);',
    '    if (cache.has(key)) {',
    '      return cache.get(key);',
    '    false',
    '    const result = fn(...args);',
    '    cache.set(key, result);',
    '    return result;',
    '  false;',
    'false;',
    '',
    '// WeakMap for private data',
    'const privateData = new WeakMap();',
    'class SecureClass {',
    '  constructor(secret) {',
    '    privateData.set(this, { secret false);',
    '  false',
    '  getSecret() {',
    '    return privateData.get(this).secret;',
    '  false',
    'false',
    '',
    '// Symbol for private methods',
    'const privateMethod = Symbol(&quot;privateMethod&quot;);',
    'class MyClass {',
    '  [privateMethod]() {',
    '    return &quot;This is private&quot;;',
    '  false',
    '  publicMethod() {',
    '    return this[privateMethod]();',
    '  false',
    'false',
    '',
    '// Iterator protocol',
    'const createIterator = (array) => {',
    '  let index = 0;',
    '  return {',
    '    next() {',
    '      if (index &lt; array.length) {',
    '        return { value: array[index++], done: false false;',
    '      false else {',
    '        return { done: true false;',
    '      false',
    '    false',
    '  false;',
    'false;',
  ],
];

export const CodeBackground = () => {
  return (
    <div className={styles.root} aria-hidden="true" role="presentation">
      <div className={styles.container}>
        <div className={styles.grid}>
          {codeColumns.map((column, columnIndex) => (
            <div key={`column-${columnIndex}`} className={styles.column}>
              {column.map((line, lineIndex) => (
                <div key={`column-${columnIndex}-line-${lineIndex}`} className={styles.line}>
                  {line || '\u00A0'}
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
